{"version":3,"sources":["../../../src/visualizations/chart/getChartData.ts"],"names":["addPointToSeries","point","seriesCollection","seriesName","undefined","name","type","data","push","getChartData","options","series","mappings","columnMapping","row","$raw","xValue","yValues","eValue","sizeValue","zValue","value","definition","definitionParts","split","String","yValue","ySeriesName","x","y","yError","size","zVal","seriesOptions","zIndex"],"mappings":"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","sourcesContent":["import { isNil, isObject, each, forOwn, sortBy, values } from \"lodash\";\r\n\r\nfunction addPointToSeries(point: any, seriesCollection: any, seriesName: any) {\r\n  if (seriesCollection[seriesName] === undefined) {\r\n    seriesCollection[seriesName] = {\r\n      name: seriesName,\r\n      type: \"column\",\r\n      data: [],\r\n    };\r\n  }\r\n\r\n  seriesCollection[seriesName].data.push(point);\r\n}\r\n\r\nexport default function getChartData(data: any, options: any) {\r\n  const series = {};\r\n\r\n  const mappings = options.columnMapping;\r\n\r\n  each(data, row => {\r\n    let point = { $raw: row };\r\n    let seriesName = null;\r\n    let xValue = 0;\r\n    const yValues = {};\r\n    let eValue: any = null;\r\n    let sizeValue: any = null;\r\n    let zValue: any = null;\r\n\r\n    forOwn(row, (value, definition) => {\r\n      definition = \"\" + definition;\r\n      const definitionParts = definition.split(\"::\") || definition.split(\"__\");\r\n      const name = definitionParts[0];\r\n      const type = mappings ? mappings[definition] : definitionParts[1];\r\n\r\n      if (type === \"unused\") {\r\n        return;\r\n      }\r\n\r\n      if (type === \"x\") {\r\n        xValue = value;\r\n        // @ts-expect-error ts-migrate(7053) FIXME: Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\r\n        point[type] = value;\r\n      }\r\n      if (type === \"y\") {\r\n        // @ts-expect-error ts-migrate(7053) FIXME: Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\r\n        yValues[name] = value;\r\n        // @ts-expect-error ts-migrate(7053) FIXME: Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\r\n        point[type] = value;\r\n      }\r\n      if (type === \"yError\") {\r\n        eValue = value;\r\n        // @ts-expect-error ts-migrate(7053) FIXME: Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\r\n        point[type] = value;\r\n      }\r\n\r\n      if (type === \"series\") {\r\n        seriesName = String(value);\r\n      }\r\n\r\n      if (type === \"size\") {\r\n        // @ts-expect-error ts-migrate(7053) FIXME: Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\r\n        point[type] = value;\r\n        sizeValue = value;\r\n      }\r\n\r\n      if (type === \"zVal\") {\r\n        // @ts-expect-error ts-migrate(7053) FIXME: Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\r\n        point[type] = value;\r\n        zValue = value;\r\n      }\r\n\r\n      if (type === \"multiFilter\" || type === \"multi-filter\") {\r\n        seriesName = String(value);\r\n      }\r\n    });\r\n\r\n    if (isNil(seriesName)) {\r\n      each(yValues, (yValue, ySeriesName) => {\r\n        // @ts-expect-error ts-migrate(2322) FIXME: Type '{ x: number; y: never; $raw: any; }' is not ... Remove this comment to see the full error message\r\n        point = { x: xValue, y: yValue, $raw: point.$raw };\r\n        if (eValue !== null) {\r\n          // @ts-expect-error ts-migrate(2339) FIXME: Property 'yError' does not exist on type '{ $raw: ... Remove this comment to see the full error message\r\n          point.yError = eValue;\r\n        }\r\n\r\n        if (sizeValue !== null) {\r\n          // @ts-expect-error ts-migrate(2339) FIXME: Property 'size' does not exist on type '{ $raw: an... Remove this comment to see the full error message\r\n          point.size = sizeValue;\r\n        }\r\n\r\n        if (zValue !== null) {\r\n          // @ts-expect-error ts-migrate(2339) FIXME: Property 'zVal' does not exist on type '{ $raw: an... Remove this comment to see the full error message\r\n          point.zVal = zValue;\r\n        }\r\n        addPointToSeries(point, series, ySeriesName);\r\n      });\r\n    } else {\r\n      addPointToSeries(point, series, seriesName);\r\n    }\r\n  });\r\n  return sortBy(values(series), ({ name }) => {\r\n    if (isObject(options.seriesOptions[name])) {\r\n      return options.seriesOptions[name].zIndex || 0;\r\n    }\r\n    return 0;\r\n  });\r\n}\r\n"],"file":"getChartData.js"}